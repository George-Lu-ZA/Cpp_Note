# 模板

模板是将数据类型作为参数的参数化的函数或类。是建立通用的与数据类型无关的算法的重要手段。定义模板是，数据类型作为参数出现，描述与数据类型无关的某一类通用的操作。模板是泛化编程的主要方法之一。

## 函数模板

定义

```c++
template<<模板形参表>><函数类型><函数名>(<函数形参表>)
{
 	函数体   
}

template<typename T> T Max(T a, T b)
{
    return a > b ? a : b;
}
```

函数模板的使用

模板需要实例化为具体函数后才能使用。实例化的函数模板称为模板函数。

当函数模板与一般函数同名时，遵循下面的调用顺序：

1. 首先调用参数完全匹配的一般函数，找到就调用它。
2. 寻找一个函数模板，使其实例化，生成一个匹配的模板函数然后调用。

## 类模板

```c++
template<typename T>  //一个或多个类型形参和普通形参
class A
{
    
};
```

类型形参由`typename`关键字及其后面的标识符构成。可以是系统的基本类型，也可以是用户自定义类型（比如一个类）。在类定义体中，以类模板函数作为某一种类型名来使用。 类模板的函数可以在类模板的定义中定义，这样它就是`inline`内联函数。也可以在类外定义。

```c++
template<typename T, int length>
void Array<T, length>::SetElement(T, x)   //此处要在类名后把模板后的形参的标识符写上，要注意
{
    
}
```

### 类模板的使用

必须先实例化为模板类，然后创建该模板类的对象后才能使用。模板类与普通类具有相同的行为。

**与函数模板不同的是**：函数模板的实例化是编译程序在处理函数调用时自动完成的。而类模板的实例化**必须要有程序员在代码中显式地指出**，即：<类模板名><<类型实参表>><对象名表>; 这点至关重要！

说明：1.类模板函数成员本身也是一个模板，只有当它被调用时才会实例化。2.由于编译系统不支持，类模板的声明和类模板成员函数的定义要放在同一个头文件中。

### 类模板的静态成员和友元

#### 静态成员

类模板的静态成员将会是类模板实例化类的静态成员，即对一个模板类的每一个实例化类，它的所有对象共享类中的静态成员。静态成员定义时不会创建，创建实例化类后，在模板类中会产生静态成员。

同样要在类外对静态数据成员进行定义。

```c++
int A<int>::m_t = 100;
```

#### 类模板的友元

在类模板的定义中同样可以包含友元。模板类可以包含如下几种友元：

1. 友元为一般函数，它将是该类模板所有实例化模板类的友元函数
2. 友元是一个函数模板，它的类型参数与类模板的类型参数无关，则该函数模板的所有实例化模板函数都是类模板的所有实例化模板类的友元函数
3. 友元是一个函数模板，但它的类型参数与类模板的类型参数有关，该友元函数模板的实例有可能只是该类模板的某些特定实例化模板类的友元

