# 第八章 继承与多态

## 8.1 继承

派生类一般来说比基类更具体。继承了基类的所有属性和方法。提高效率，避免错误。定义语法如下：

```c++
class 派生类名:继承方式 基类名
{
    派生类成员声明
};
```

### 访问控制方式和派生类的继承方式

1.成员的访问控制方式

结合之前学习的内容：public，任何地方都能访问，protected，在该类激起派生类的成员函数中可以直接访问。如果希望在派生类中直接访问基类的成员，则可以将基类的成员声明为public，为了实现封装，声明为protected。

2.派生类的继承方式

定义派生类的时候可以指定的继承方式包括public(公有继承)，protected(保护继承)，private(私有继承，**默认方式**)。注意，通过设置继承方式，可以使**基类成员的访问控制方式在派生类中发生变化**，换句话说，这是一种“变身”，派生类中从基类继承过来的成员的访问控制方式是怎样的，是由1.该成员在基类中的访问控制方式，2.继承方式所共同决定的。见下表

|              |           | 访问控制方式       |           |
| ------------ | :-------: | ------------------ | --------- |
| **继承方式** |  public   | private            | protected |
| public       |  public   | 派生类不可直接访问 | protected |
| private      |  private  | 不可直接访问       | private   |
| protected    | protected | 不可直接访问       | protected |

### 成员函数的重定义

从基类继承过来的函数给人家改喽，实现更多样的功能。格式上保持返回类型和函数名不变，直接改写函数体就可以。这样，当使用派生类的对象调用时，就会调用这个新定义的同名函数。而用基类的对象调用时，则会调用基类的原来的函数。区分：函数重载根据形参的不同选择函数调用。函数重定义则根据对象类型。

### 派生类的构造函数和析构函数

派生类不会继承基类的构造和析构函数，初始化从基类继承过来的对象时会自动调用基类的构造函数。因此，派生类的构造函数主要是对新添加的数据成员的初始化。同理，析构函数也是新析构新，旧的调用。

**派生类构造函数的定义**

```c++
派生类名（形参列表）: 基类名（实参列表）
{
    //派生类成员的初始化
}
//如果要调用无参构造函数，则实参列表为空
派生类名（形参列表）
{
    //派生类成员的初始化
}
//等价于
派生类名（形参列表）: 基类名（ ）
{
    //派生类成员的初始化
}
```

派生类析构函数的定义和基类完全相同，因为他没有参数的问题。

**构造函数和析构函数的调用顺序问题**

创建派生类对象时，先调用基类的构造函数，再调用派生类的构造函数。析构函数的调用顺序总是与构造函数相反。

### 多继承

```c++
class 派生类名:继承方式 基类名1, 继承方式 基类名2, ··· ,继承方式 基类名n
{
    派生类成员声明
};
```

说明：不同的基类可以使用不同的继承方式。必须先定义一个类，才能被继承。

创建通过多继承定义的派生类对象时，也会先调用基类的构造函数，再调用派生类的构造函数。析构函数的调用顺序总是与构造函数相反。各基类构造函数的调用顺序与声明顺序一致。

### 多继承中的二义性问题

考虑1-->2-->1这样一个三层继承关系。相当于最下方的派生类有两份最初的基类。所以如果在最下派生类中调用最上基类的成员。不知道从哪个中间基类中去调用。产生二义性。解决这个问题，可以使用作用域运算符`::`来说明走哪条路。例如：

```c++
cout << ta.Teacher::GetName() <<endl;
```

但这样调用要知道类的继承关系，不方便使用。所以用虚拟继承解决多继承中的二义性问题。

### 虚拟继承和虚基类

定义派生类时，可以通过虚拟继承方式将基类声明为虚基类，虚基类的成员在类的继承关系中只会被继承一次。从而解决上述的二义性问题。语法如下:

```c++
class 派生类名:virtual 继承方式 虚基类名
{
    
};
```

其中关键字virtual和继承方式的顺序可以调换。注意理解：**虚基类后续层次中的类都是直接从虚基类中继承其成员。** 

构造函数和析构函数，创建派生类的对象时，会先调用虚基类的构造函数，再按继承顺序调用基类的构造函数，最后调用派生类的构造函数。析构函数正好相反。需要注意的是，在调用基类的构造函数时不会再调用虚基类的构造函数。

## 8.2多态

### 类型兼容和多态性的概念

类型兼容是多态性的前提，指在基类对象可以出现的任何地方都可以用**公有**派生类的对象来代替。

* 可以用派生类对象为基类对象赋值
* 可以用派生类对象初始化基类引用
* 可以用派生类对象地址为基类指针赋值

说明：基类对象不能代替派生类对象。用派生类对象代替基类对象进行赋值操作后，通过基类对象，基类对象引用和基类对象指针，只能访问派生类从基类继承的成员。  通过类型兼容，对于基类及其公有派生类的对象，可以使用相同的函数统一进行处理。

### 多态性的实现

#### 动态绑定与虚函数

前面例子中的函数调用，都是采用**先期绑定**的方式。所谓“绑定”，就是建立函数调用和函数本体的关联。如果绑定发生于程序运行之前（由编译器和链接器完成），则称为“先期绑定”（又称“静态绑定”）。要实现多态性，就要进行“后期绑定”（又称“动态绑定”），即绑定发生于程序运行过程中。
C++通过虚函数实现动态绑定技术。虚函数的声明方法是在基类的函数声明前或函数定义的函数头前（无函数声明时）加上关键字 virtual。

```c++
virtual void Display()
{
    
}
```

虚函数具有继承性，只要基类中的函数被声明为虚函数，则在派生类中对虚函数进行重定义时，无论是否加了virtual关键字，这个函数都是虚函数。

说明：只有使用基类的指针或引用调用虚函数时才能实现多态性。如果使用对象调用虚函数，则必然是调用该对象所属类的成员函数不具有多态性。

## 8.3抽象类

能够定义对象的类叫具体类，而抽象类不能实例化对象。它的唯一用处是为其它类提供合适的基类，其他类可以从它这里继承和实现接口。抽象类仅仅表示一个概念，将其实例化没有任何意义。

### 抽象类的实现

一个类是具体类还是抽象类，主要看它是否含有纯虚函数，包含纯虚函数的类就是抽象类。纯虚函数就是在声明时初始化为零，没有函数体的虚函数。其声明形式如下：

```c++
virtual<函数类型>纯虚函数名(<形参类型表>)=0;
```

由抽象类派生的新类如果有自己的纯虚函数，则它也是抽象类。